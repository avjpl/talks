<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .remark-slide-number { display: none; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Functional Programming Fundementals
<br>
<center><small>Tom Duncalf | <a href='mailto:tom@tomduncalf.com'>tom@tomduncalf.com</a> | <a href='https://twitter.com/tomduncalf'>@tomduncalf</a></small></center>

---

### The book this is based on

<center>
  <img src='./book.png' width='50%'>
  <br/>
  <small>https://github.com/MostlyAdequate/mostly-adequate-guide</small>
</center>

---

### Concepts we'll cover

* Pure functions

* Type signatures

* First class functions

* Currying

* Composition

* Functors

* Monads

---

### Pure functions

--

* A pure function is a function that, given the same input(s), will always return the same output

* No dependency on anything external to its arguments

--

```
let minPasswordLength = 8

// Not pure
const isGoodPassword = function(password) {
  return password.length > minPasswordLength
}

isGoodPassword('tom') // returns: false
isGoodPassword('tomtomtom') // returns: true
```

--

```
// Pure
const isGoodPassword = function(password, minLength) {
  return password.length > minLength
}

isGoodPassword('tom', 8) // returns: false
isGoodPassword('tomtomtom', 8) // returns: true
```

---

### Pure functions

* No observable side effects

--

* <b>Side effect</b>: "any interaction with the world outside of our function"

--

  * making an HTTP call

  * interacting with a database

  * printing to the screen / logging

  * changing the file system

--

* How can we program without side effects?!

--

* We can't - but FP aims to execute them in a controlled way

---

### Why pure functions?

--

* <b>Easy to reason about</b>: we know a pure function's dependencies, and that it won't change the outside world

--

* <b>Cacheable</b> (memoization): we know the same input will always give the same output

--

* <b>Testable</b>: we don't need to mock complex environmental dependencies

--

* <b>Parallelisable</b>: do not need access to shared memory, no race conditions

--

* Meets the mathematical definition of a function:

<center><img src='function.gif' height='30%'></center>
---

### Type signatures

--

* Specifies what types of inputs a function takes and what type it returns (String, Number, etc)

--

* JS has no type checking but useful to document and think about types

---

### Hindley-Milner type signatures

```
// stringLength :: String -> Number
const stringLength = function(inputString) {
    return inputString.length
}
```

--

```
// splitWords :: String -> [String]
const splitWords = function(inputString) {
    return inputString.split(' ')
}
```

--

```
// splitByCharacter :: String -> String -> [String]
const splitByCharacter = function(inputString, char) {
    return inputString.split(char)
}
```

--

```
// splitAndTransformWords :: String -> (String -> String) -> [String]
const splitAndTransformWords = function(inputString, transformFn) {
    return inputString.split(' ').map(word => transformFn(word))
}
```

--

```
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = function(inputArray, transformFn) {
    return inputArray.map(el => transformFn(el))
}
```

---

### First class functions

--

* Functions are treated just like any other data type

* Functions be passed as arguments to other functions, returned from functions, stored in variables, arrays, etc.

* They are only called when invoked with `()`

--

```
// This...
// debug :: String -> String
const debug = function(string) {
  console.log(string)
}
```

--

```
// ...is the same as:
// debug :: String -> String
const debug = console.log
```

--

```
// This:
const passwords = ['test', 'password123', 'hello']
passwords.map(password => isGoodPassword(password)) // returns [false, true, false]
```

--

```
// ...is the same as:
passwords.map(isGoodPassword) // returns [false, true, false]
```

---

### Why first class functions?

* Less code, more readable

* Reduces the need to name things which allows us to write more generic code - a common theme in functional programming

---

### Curried functions

--

* A curried function can be called with fewer arguments than it expects

* If called with fewer arguments, will return a "partially applied" function that takes the remaining arguments

--

```
// add :: Number -> (Number -> Number)
const add = function(x) {
  return function(y) {
    return x + y
  }
}
```
--

```
add(1) // returns: function(y) { return 1 + y }
```

--

```
add(1)(2) // returns: 3
```

--

```
// addOne :: Number -> Number
const addOne = add(1)
// addTen :: Number -> Number
const addTen = add(10)

addOne(2) // returns: 3
addTen(2) // returns: 12
```

---

### Curried functions

* Javascript functions are not curried by default

--

* `curry` (for `n` arguments) is included in `lodash` and `ramda`

--

```
const R = require('ramda')

// add :: Number -> Number -> Number
const add = R.curry(function(x, y) {
  return x + y
})

add(1) // returns: function(y) { return 1 + y }
add(1)(2) // returns: 3
add(1, 2) // returns: 3
```

--

* All functions in `ramda` and `lodash/fp` are curried by default and the data argument comes last so we can "pre-fill" the function

```
// R.indexOf(search, inputArray) is a curried function: a -> [a] -> Number

// indexOfAt :: String -> Number
const indexOfAt = R.indexOf('@')
indexOfAt('tom@tomduncalf.com') // returns: 3

// We couldn't do this (as easily...) if it were R.indexOf(inputAarray, search)
```

---

### Why currying?

--

* Allows us to easily make new domain-specific functions from generic ones

```
// R.test is a curried function: Regexp -> String -> Boolean
R.test(/hello/, 'hello world') // returns: true

// isGmailAddress :: String -> Boolean
const isGmailAddress = R.test(new RegExp('@gmail.com$'))

isGmailAddress('test@gmail.com') // returns: true
isGmailAddress('test@hotmail.com') // returns: false
```

--

* Currying becomes useful when combined with composition

---

### Composition

--

* Composition starts to demonstrate the power of working with pure, first class, curried functions

--

```
// compose :: (b -> c) -> (a -> b) -> (a -> c)
const compose = function(f, g) {
  return function(x) {
    return f(g(x))
  }
}
```
* `f` and `g` are functions, `x` is the value being piped through them
* Data flows from right to left

--

```
// doublePlusOne :: Number -> Number
const doublePlusOne = compose(R.add(1), R.multiply(2))
// same as R.add(1, R.multiply(2))

doublePlusOne(3) // returns: 7
```

---

### Composition example

* Split a sentence into words, filter out words < 3 chars, calculate average word length

```
// average :: [Number] -> Number
```

--

Without composition:
```
// avgBigWordLength :: String -> Number
const avgBigWordLength = function(input) {
  const words = input.split(' ')
  const wordLengths = words.map(word => word.length)
  const filteredLength = wordLength.filter(length => length > 3)
  
  return average(filteredLength)
}
```

--

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = function(input) {
  return log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
}
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(`input.split(' ')`.map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ')`.map(w => w.length)`.filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length)`.filter(l => l > 3)`))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(`average`(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  `log`(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With functions:
```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(R.filter(R.lt(3), R.map(R.length, R.split(' ', input)))))
```

--

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  `R.compose`(log, average, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, R.filter(R.lt(3)), R.map(R.length), `R.split(' ')`)
```


```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, R.filter(R.lt(3)), `R.map(R.length)`, R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, `R.filter(R.lt(3))`, R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
// filter(lt(3)): [5, 5]                                    [Number]
```

---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, `average`, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
// filter(lt(3)): [5, 5]                                    [Number]
// average:       5                                          Number
```
---

### Composition example

```
// avgBigWordLength :: String -> Number
const avgBigWordLength = input =>
  log(average(input.split(' ').map(w => w.length).filter(l => l > 3)))
```

With composition (and curried functions):

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(`log`, average, R.filter(R.lt(3)), R.map(R.length), R.split(' '))
```

```
avgBigWordLength('Hello world how are you?')     // input is String
// split:         ['hello', 'world', 'how', 'are', 'you?']  [String]
// map(length):   [5, 5, 3, 3, 4]                           [Number]
// filter(lt(3)): [5, 5]                                    [Number]
// average:       5                                          Number
// log:           5                                          Number
```

--

* "Pointfree" style: doesn't mention the data we are operating on

--

* More readable, more compact, clear flow of data along "pipeline", no placeholder variables

---

### Composition

* But how do we handle potential errors?

--

```
const address1 = { street: 'Test Street', postcode: 'A1 1AA' }
const address2 = { street: 'Test Street' }

// R.prop :: b -> {b: a} -> a | Undefined
R.prop('postcode', address1) // returns: 'A1 1AA'
R.prop('postcode', address2) // returns: undefined
```

--

```
// postcodeLength :: Object -> Number | ???
const postcodeLength = R.compose(R.length, R.replace(/ /, ''), R.prop('postcode'))
```

--

```
postcodeLength(address1) // returns: 5
postcodeLength(address2) // Exception: Cannot read property 'replace' of undefined
```

--

* We don't want exceptions in our code

* Could wrap `replace` in a function with a null test... but we don't want to do this all the time
--

* And what about handling side effects?!

---

### Functors

--

```
const Container = function(x) {
  this.__value = x // treat this as private
}

// of :: a -> Container a
// Sometimes also called pure, point, unit or return
Container.of = x => new Container(x)
```
--

```
Container.of(4) // returns: {"__value": 4}, but let's call this Container(4)
Container.of('hello world') // returns: Container('hello world')
Container.of(Container.of({ id: 1 })) // returns: Container(Container({ id: 1 }))
```
--

* Add a `map` function to allow us to apply functions to the value inside

```
// map :: (a -> b) -> Container a -> Container b
Container.prototype.map = function(fn) {
  return Container.of(fn(this.__value))
}
```

--

```
const four = Container.of(4)
four.map(x => x + 2) // returns: Container(6)

const hello = Container.of({ message: 'hello world' })
hello.map(R.prop('message')).map(R.length).map(R.concat('length is: ')) // returns: Container('length is: 11')
```

---

### Functors

* "A functor is a type that implements `map` and obeys some laws"

* Why would we want to do contain a value and run `map` to get to it?
--


* Abstraction of function application - with `map`, we ask the container to run the function for us
* Allows to provide useful behaviour while mapping
---

### Maybe

```
const Maybe = function(x) {
  this.__value = x
}

// of :: a -> Maybe a
Maybe.of = x => new Maybe(x)

// map :: (a -> b) -> Maybe b
Maybe.prototype.map = function(fn) {
  return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this.__value));
}

// isNothing :: Boolean
Maybe.prototype.isNothing = function() {
  return (this.__value === null || this.__value === undefined)
}
```

--

```
Maybe.of('hello world') // returns: Maybe('hello world')
Maybe.of('hello world').map(R.match(/hello/)).map(R.length) // returns: Maybe(1)
```

--

```
Container.of(null).map(R.match(/hello/)).map(R.length)
  // Exception: TypeError: Cannot read property 'match' of null
```

--

```
Maybe.of(null).map(R.match(/hello/)).map(R.length) // returns: Maybe(null)
```

---

### Maybe

* `Maybe` takes care of null checking for us
* `Maybe` is typically used as the return type of functions that may fail to return a result

```
// safeHead :: [a] -> Maybe(a)
const safeHead = xs => Maybe.of(xs[0])

safeHead([1, 2, 3]) // returns: Maybe(1)
safeHead([]) // returns: Maybe(null)
```

* Gives safety by forcing calling code to handle the `null` case - we can only get at the value by calling `map`

--

* `map` allows us to compose functors

```
// headLength :: [a] -> Maybe String
const headLength = R.pipe(safeHead, R.map(R.length), R.map(R.concat('Length: ')))

headLength(['one', 'two', 'three']) // returns: Maybe('Length: 3')
headLength([]) // returns: Maybe(null)
```
--

* The function being called doesn't have to know about functors - map "lifts" the function

---

### Maybe

* We can get the value out of `Maybe` using the `maybe` function

```
//  maybe :: b -> (a -> b) -> Maybe a -> b
const maybe = curry((defaultValue, transformFn, m) =>
  m.isNothing() ? defaultValue : transformFn(m.__value)

// getResult :: Maybe a -> a | String
const getResult = maybe('No item found', x => x)

getResult(safeHead([1, 2, 3])) // returns: 1
getResult(safeHead([])) // returns: 'No item found'
```

--

* Or using `getOrElse`

```
Maybe.prototype.getOrElse = function(defaultValue) {
  return this.isNothing() ? defaultValue : this.__value
}

safeHead([1, 2, 3]).getOrElse('No item found') // returns: 1
safeHead([]).getOrElse('No item found') // returns: 'No item found'
```

--

* Real implementation of `Maybe` is split into two types rather than doing a `null` check: `Maybe.Just(x)` and `Maybe.Nothing`

```
const safeHead = xs => xs.length ? Maybe.Just(xs[0]) : Maybe.Nothing()
```

---

### IO

--

* We can make a function which has a side effect pure by wrapping it in another function:

```
// getFromStorage :: String -> (_ -> String)
const getFromStorage = function(key) {
  return function() {
    return window.localStorage[key]
  }
}
```

* We always get the same output for the same input (a function that gets that key from localStorage)

* But how can we make this useful for managing side effects?

---

### IO

```
const IO = function(fn) {
  // Same as __value, but renamed
  this.unsafePerformIO = fn
}

IO.of = function(x) {
  return new IO(function() {
    return x
  })
}

IO.prototype.map = function(fn) {
  return new IO(R.compose(fn, this.unsafePerformIO))
}
```

--

```
// url :: IO String
const url = IO.of(window.location.href) // returns: {unsafePerformIO: [Function]}

url.unsafePerformIO() // returns: http://www.google.com
```

--

```
const url = new function() {
  this.unsafePerformIO = function() {
    return window.location.href
  }
}
```

---

### IO

* We can use `map` to build up a composed chain of actions, ready to be performed by calling `unsafePerformIO`

```
// url :: IO String
const url = IO.of(window.location.href)

// urlEmail :: IO String
const urlEmail = url.map(R.match(/[a-z]*\.com/)).map(R.nth(0)).map(R.concat('@'))

urlEmail.unsafePerformIO() // returns: '@google.com'
```

--

* Internally, we have built up something like:

```
const urlEmail = new function() {
  this.unsafePerformIO = R.compose(
    R.concat('@'),
    R.nth(0),
    R.match(/[a-z]*\.com/),
    function() { return window.location.href }
  )
}
```

--

* IO enables us to control side effects by pushing responsibility for running them to calling code (and indicates side effects in the type signature)
---

### Task

* `Task` is designed to help us deal with asynchronous code

--

```
// Using Data.Task from folktale

// readFile :: String -> Task Error String
const readFile = filename => {
  return new Task(function(reject, result) {
    fs.readFile(filename, 'utf-8', (err, data) => {
      err ? reject(err) : result(data)
    })
  })
}
```

```
// myFileLength :: Task Error Number
const linesInMyFile = readFile('my_file.txt').map(R.split('\n')).map(R.length)

linesInMyFile.fork(
  error => console.error(error),
  result => console.log('There are ' + result + ' lines in my file')
)
```

--

* Looks familiar? `Promises` are basically `Tasks`, with `then` instead of `map`

---

### Monads

--

* Nested functors lead to uncomfortable code:

```
// safeProp :: Key -> {Key: a} -> Maybe a
const safeProp = R.curry((key, obj) => Maybe.of(obj[key]))

// safeHead :: [a] -> Maybe a
const safeHead = safeProp(0)

// firstAddressStreet :: Object -> Maybe(Maybe(Maybe String))
const firstAddressStreet = R.compose(
  R.map(R.map(safeProp('street'))),
  R.map(safeHead),
  safeProp('addresses')
)
```

--

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})
```

---

### Monads

* Nested functors lead to uncomfortable code:

```
// safeProp :: Key -> {Key: a} -> Maybe a
const safeProp = R.curry((key, obj) => Maybe.of(obj[key]))

// safeHead :: [a] -> Maybe a
const safeHead = safeProp(0)

// firstAddressStreet :: Object -> Maybe(Maybe(Maybe String))
const firstAddressStreet = R.compose(
  R.map(R.map(safeProp('street'))),
  R.map(safeHead),
  `safeProp('addresses')`
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
```

---

### Monads

* Nested functors lead to uncomfortable code:

```
// safeProp :: Key -> {Key: a} -> Maybe a
const safeProp = R.curry((key, obj) => Maybe.of(obj[key]))

// safeHead :: [a] -> Maybe a
const safeHead = safeProp(0)

// firstAddressStreet :: Object -> Maybe(Maybe(Maybe String))
const firstAddressStreet = R.compose(
  R.map(R.map(safeProp('street'))),
  `R.map(safeHead)`,
  safeProp('addresses')
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
// map(safeHead):      Maybe(Maybe({ street: 'Test St.' }))  Maybe(Maybe Object)
```

---

### Monads

* Nested functors lead to uncomfortable code:

```
// safeProp :: Key -> {Key: a} -> Maybe a
const safeProp = R.curry((key, obj) => Maybe.of(obj[key]))

// safeHead :: [a] -> Maybe a
const safeHead = safeProp(0)

// firstAddressStreet :: Object -> Maybe(Maybe(Maybe String))
const firstAddressStreet = R.compose(
  `R.map(R.map(safeProp('street')))`,
  R.map(safeHead)`,
  safeProp('addresses')
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
// map(safeHead):      Maybe(Maybe({ street: 'Test St.' }))  Maybe(Maybe Object)
// map(map(safeProp)): Maybe(Maybe(Maybe('Test St.')))       M(M(Maybe String)))
```

---

### Monads

* `join` removes a 'layer' when we have two nested functors of the same type

```
Maybe.prototype.join = function() {
  return this.isNothing() ? Maybe.of(null) : this.__value
}

IO.prototype.join = function() {
  return this.unsafePerformIO()
}
```

```
const mm = Maybe.of(Maybe.of('Hello world')) // Maybe(Maybe('Hello world'))
mm.join()                                    // Maybe('Hello world')

const ioio = IO.of(IO.of(window.location.href)) // IO(IO('http://google.com'))
ioio.join                                       // IO('http://google.com')
```

--

* "Any functor which defines a `join` method, has an `of` method, and obeys a few laws is a monad"

---

### Monads

```
// firstAddressStreet :: Object -> Maybe(Maybe(Maybe String))
const firstAddressStreet = R.compose(
  R.map(R.map(safeProp('street'))),
  R.map(safeHead),
  safeProp('addresses')
)
```
--

```
//  join :: Monad m => m (m a) -> m a
const join = function(nestedMonad) {
  return nestedMonad.join()
}
```

--

```
// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  join,
  R.map(safeProp('street')),
  join,
  R.map(safeHead),
  safeProp('addresses')
)
```

---

### Monads

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  join,
  R.map(safeProp('street')),
  join,
  R.map(safeHead),
  safeProp('addresses')
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})
```

---

### Monads

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  join,
  R.map(safeProp('street')),
  join,
  R.map(safeHead),
  `safeProp('addresses')`
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
```

---

### Monads

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  join,
  R.map(safeProp('street')),
  join,
  `R.map(safeHead)`,
  safeProp('addresses')
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
// map(safeHead):      Maybe(Maybe({ street: 'Test St.' }))  Maybe(Maybe Object)
```

---

### Monads

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  join,
  R.map(safeProp('street')),
  `join`,
  R.map(safeHead),
  safeProp('addresses')
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
// map(safeHead):      Maybe(Maybe({ street: 'Test St.' }))  Maybe(Maybe Object)
// join:               Maybe({ street: 'Test St.' })         Maybe Object
```

---

### Monads

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  join,
  `R.map(safeProp('street'))`,
  join,
  R.map(safeHead),
  safeProp('addresses')
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
// map(safeHead):      Maybe(Maybe({ street: 'Test St.' }))  Maybe(Maybe Object)
// join:               Maybe({ street: 'Test St.' })         Maybe Object
// map(safeProp):      Maybe(Maybe('Test St.'))              Maybe(Maybe String))
```


---

### Monads

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  `join`,
  R.map(safeProp('street')),
  join,
  R.map(safeHead),
  safeProp('addresses')
)
```

```
firstAddressStreet({
  addresses: [{ street: 'Test St.'}]
})

// safeProp:           Maybe([{ street: 'Test St.'}])        Maybe [Object]
// map(safeHead):      Maybe(Maybe({ street: 'Test St.' }))  Maybe(Maybe Object)
// join:               Maybe({ street: 'Test St.' })         Maybe Object
// map(safeProp):      Maybe(Maybe('Test St.'))              Maybe(Maybe String))
// join:               Maybe('Test St.')                     Maybe String
```

---

### Monads

* `map` followed by `join` is a common pattern - abstracted into a function called `chain` (also know as `flatMap`, `bind` or `>>=`)

```
//  chain :: Monad m => (a -> m b) -> m a -> m b
const chain = R.curry((mapFn, monad) =>
  return monad.map(mapFn).join() // or R.compose(R.join, R.map(mapFn))(monad)
});
```

--

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  `join,`
  `R.map`(safeProp('street')),
  `join,`
  `R.map`(safeHead),
  safeProp('addresses')
)
```

---

### Monads

* `map` followed by `join` is a common pattern - abstracted into a function called `chain` (also know as `flatMap`, `bind` or `>>=`)

```
//  chain :: Monad m => (a -> m b) -> m a -> m b
const chain = R.curry((mapFn, monad) =>
  return monad.map(mapFn).join() // or R.compose(R.join, R.map(mapFn))(monad)
});
```

```
// safeProp :: Key -> {Key: a} -> Maybe a
// safeHead :: [a] -> Maybe a

// firstAddressStreet :: Object -> Maybe String
const firstAddressStreet = R.compose(
  `chain`(safeProp('street')),
  `chain`(safeHead),
  safeProp('addresses')
)
```

---

### Summary


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'javascript',
        highlightSpans: true
      });
    </script>
  </body>
</html>
