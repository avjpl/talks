<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .remark-slide-number { display: none; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# FP Fundamentals
## Functors, monads and more
<br>
<center><small>Tom Duncalf | <a href='mailto:tom@tomduncalf.com'>tom@tomduncalf.com</a> | <a href='https://twitter.com/tomduncalf'>@tomduncalf</a></small></center>

---

### Why?

* A lot of interest in FP at the minute
* Some of the fundamental concepts (functors, monads etc.) are sometimes made to seem very complicated
* The basic concepts are actually quite simple (and useful)
* Don't have to use a pure FP language - examples in Javascript
* I am not an expert :)

---

### The book this is based on

<center>
  <img src='./book.png' width='50%'>
  <br/>
  <small>https://github.com/MostlyAdequate/mostly-adequate-guide</small>
</center>

---

### Concepts we'll cover

* Pure functions
* First class functions
* Hindley-Milner type signatures
* Currying
* Composition
* Pointfree style
* Functors
* Monads

---

### Pure functions

--

* A pure function is a function that, given the same input, will always return the same output and does not have any observable side effect.

---

### Pure functions

* <span style='opacity:0.3'>A pure function is a function that, </span>given the same input, will always return the same output <span style='opacity:0.3'>and does not have any observable side effect.</span>
<center><img src='function.gif' height='30%'></center>

---

### Pure functions

* A pure function is a function that, given the same input, will always return the same output and does not have any observable side effect.
<center><img src='function.gif' height='30%'></center>
* No dependence on factors external to the input

---

### Pure functions

* Side effect: "anything that occurs in our computation besides the calculation of a result"
* "Side effects are a primary cause of incorrect behaviour"
--

* Examples include:
  * changing the file system
  * inserting a record into a database
  * making an http call
  * printing to the screen / logging
  * obtaining user input
  * querying the DOM
  * any interaction with the world outside of the function!

---

### Pure functions

* How can we program without side effects?
  * We can't - we aim to control them and run them in a controlled manner
  * more on this later...

---

### Why pure functions?

* <b>Cacheable</b> (memoization): we know the same input will always give the same output
--

* <b>Portable</b>: a function's dependencies are explicit
--

* <b>Testable</b>: we don't need to mock complex dependencies, just assert outputs given inputs
--

* <b>Referential transparency</b>: code can be substituted for its generated value
--

* <b>Parallelisable</b>: do not need access to shared memory, no race conditions

---

### Hindley-Milner type signatures

--

* Specifies what types of inputs a function takes and what type it returns
--

* JS has no type checking but useful for documentation
* Can often understand what a function does just from name and type signature
* Can be useful for searching for a function e.g. Ramda docs, Hoogle

---

### Hindley-Milner type signatures

```
// stringLength :: String -> Number
const stringLength = input => {
    return stringLength.length
}
```

--

```
// splitWords :: String -> [String]
const splitWords = input => {
    return input.split(' ')
}
```

--

```
// splitByCharacter :: String -> String -> [String]
const splitByCharacter = (input, char) => {
    return input.split(char)
}
```

--

```
// splitAndTransformWords :: String -> (String -> String) -> [String]
const splitAndTransformWords = (input, transformFn) => {
    return s.split(' ').map(word => transformFn(word))
}
```

--

```
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => {
    return inputArray.map(el => transformFn(el))
}
```

---

### First class functions

---

### First class functions

* Functions are treated just like any other data type
* They can be passed around, stored in variables, arrays, etc.
* They are only called when invoked with `()`

--

```
// hi :: String -> String
const hi = name => {
    return "Hi " + name
}
```

--

```
// This:
// greet :: String -> String
const greet = name => {
  return hi(name)
}

// or this:
// greet :: String -> String
const greet = name => hi(name)
```

--

```
// ...is the same as:
// greet :: String -> String
const greet = hi
```

---

### First class functions

```
// This:
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => {
    return inputArray.map(el => transformFn(el))
}
```

--

```
// ...is the same as:
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => {
    return inputArray.map(transformFn)
}

// or:
// transformArray :: [a] -> (a -> b) -> [b]
const transformArray = (inputArray, transformFn) => inputArray.map(transformFn)
```

--

```
// This:
transformArray(['one', 'two', 'three'], x => x.length)
```

--

```
// ...is the same as:
// length :: a -> Number
const length = x => x.length
transformArray(['one', 'two', 'three'], length)
```

---

### Why first class functions?

* Less code, more readable
* Easier to change function arguments - no need to update everywhere
* Reduces the need to name arguments which allows us to write more generic code - common theme in FP

--

```
// Specific to our current domain:
// validArticles :: [a] -> [a]
const validArticles = articles => {
  return articles.filter(article => article !== null && article !== undefined)
}

// Generic and reusable:
// compact :: [a] -> [a]
const compact = xs => {
  return xs.filter(x !== null && x !== undefined)
}
```

---

### Currying

--

* A curried function can be called with fewer arguments than it expects, and will return a function that takes the remaining arguments

---

### Currying

* A curried function can be called with fewer arguments than it expects, and will return a partially applied function that takes the remaining arguments

--

```
// add :: a -> (a -> a) - e.g. Number -> (Number -> Number)
const add = (x) => {
  return (y) => {
    return x + y
  }
}

// Or...
// add :: a -> (a -> a)
const add = x => y => x + y
```

--

```
add(1) // returns: function(y) => { return x + y }
add(1)(2) // returns: 3
```

--

```
// addOne :: Number -> Number
const addOne = add(1)
// addTen :: Number -> Number
const addTen = add(10)

addOne(2) // returns: 3
addTen(2) // returns: 12
```

---

###Â Currying

* `curry` (for `n` arguments) is included in `lodash` and `ramda`

--

* Order of arguments is important - the data should come last so we can "pre-fill" the function <small>(see <a href='https://www.youtube.com/watch?v=m3svKOdZijA'>Hey Underscore, You're Doing It Wrong!</a>)</small>

    Consider: `_.indexOf(array, search)` vs `_.indexOf(search, array)`

  * Although we could use `_.curryRight`, better off using `lodash/fp` or `ramda` (all functions pre-curried)

---

### Why currying?

--

* Allows us to easily make new domain functions from generic ones

```
const isGmailAddress = R.test(new RegExp('@gmail.com$'))
isGmailAddress('test@gmail.com') // returns: true
isGmailAddress('test@hotmail.com') // returns: false
```

--

* Helps avoid the overhead of passing arguments around all the time


--


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'javascript'
      });
    </script>
  </body>
</html>
