
### Composition

* Composition of pure functions mirrors mathematical function composition: <em>(g ∘ f)(x) = g(f(x))</em> (generalized in category theory)

--

* Composition is associative: <em>f ∘ (g ∘ h) = (f ∘ g) ∘ h</em>

--
* We can extract any group of functions into their own composition:

```
// avgBigWordLength :: String -> Number
const avgBigWordLength =
  R.compose(log, average, `R.filter(R.lt(3)), R.map(R.length)`, R.split(' '))
```

--

```
const lengthsLt3 = R.compose(`R.filter(R.lt(3)), R.map(R.length)`)
const avgBigWordLength = R.compose(log, average, `lengthsLt3`, R.split(' '))
```


---

### How is currying pure?

* Each single argument of the function returns a new function expecting the remaining arguments
--

* Always returns the same function for the same input argument, so still pure: 1 input maps to exactly 1 ouptut

<center><img src='function.gif' height='30%'></center>
--

* Allowing more than one argument at a time can be seen as a convenience

```
doSomething(1)(2)(3) === doSomething(1, 2, 3)
```

---
