<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
          font-family: 'Helvetica Neue', Arial, sans-serif;
          font-weight: 200;
      }

      body, a {
          color: white;
      }

      .remark-slide-scaler {
          box-shadow: none;
      }

      .remark-container, .remark-slide-content {
          background: #232323;
      }

      h1, h2, h3 {
        font-family: 'Helvetica Neue', Arial, sans-serif;
        font-weight: 300;
      }

      .remark-code, .remark-inline-code {
          font-family: 'Ubuntu Mono';
      }

      .remark-slide-number {
          display: none;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Unit Testing<br/>React Applications
<br>
<center><small>Tom Duncalf | <a href='mailto:tom@tomduncalf.com'>tom@tomduncalf.com</a> | <a href='https://twitter.com/tomduncalf'>@tomduncalf</a></small></center>

---

### Overview

* What is unit testing?

* Why unit test?

* `mocha` and `chai`

* Unit testing React components

* `enzyme`

* Common scenarios

---

### What is unit testing?

<blockquote>“Unit testing is a software development process in which the smallest testable parts of an application, called units, are individually and independently scrutinized for proper operation. Unit testing is often automated but it can also be done manually.”</quote>

--

* Example: "`add(1, 1)` should equal `2`"

--

* How small should a unit be?

--

* vs. integration testing, end to end testing

???
How small? ideally testing a small piece of code such as a (public) function with no depedencies on other parts of your code - library dependencies are ok

---

### Why unit test?

--
* Check our code behaves as we expect it to

--

* Check our code handles edge cases/errors correctly

--

* Check our code is syntactically correct (especially in a dynamic language)

--

* Reduce dependency on end-to-end tests - faster, more accurate

--

* Acts as "executable documentation" for our code

--

* Enables refactoring with confidence

--

* Helps writing code where inputs and outputs are known but method isn't

--

* Can help us write better code


???
Dev's opinions on unit testing run from "won't write anything without a unit test" to "won't write a unit test for anything"
Does represent extra effort so why should we do it?

Document e.g. that a certain edge case handling is correct

---

### Testing Javascript: `mocha`

--

* Lots of libraries and tools to choose from: `mocha`, `karma`, `jasmine`, `qunit`, `jsunit`, `wallaby`, `chutzpah`, `ava`, `tape`, `chai`, `sinon`, `jest`...

--

* We will use `mocha` as the core test framework and test runner


```
// add.js
module.exports = (a, b) => a + b
```

```
// add.spec.js
const assert = require('assert')
const add = require('./add')

describe('add function', () => {
    it('should add two numbers together correctly', () => {
        assert(add(1, 2) === 3)
    })
})
```

```bash
$ npm install -g mocha
$ mocha add.spec.js

  add function
    [✓] should add two numbers together correctly

  [1 passing] (7ms)
```

---

### Testing Javascript: `mocha`

```
describe('add function', () => {
    it('should add two numbers together correctly', () => {
        assert(add(1, 2) === 3)
    })

    it('should add three numbers together correctly', () => {
        assert(add(1, 2, 3) === 6)
    })
})
```

```bash
$ mocha add.spec.js

  add function
    ✓ should add two numbers together correctly
    1) should add three numbers together correctly

  1 passing (9ms)
  1 failing

  1) add function should add three numbers together correctly:

      AssertionError: false == true
      + expected - actual

      -false
      +true

      at Context.<anonymous> (add.spec.js:11:9)
```

---

### Testing Javascript: `chai`

--

* `chai` is an assertion library, which allows us to write our assertions in three ways:

```
const add = require('./add')
const chai = require('chai')
chai.should()
const expect = chai.expect
const assert = chai.assert

describe('add function', () => {
    it('should add two numbers together correctly', () => {
        // BDD "should" style
        add(1, 2).should.equal(3)

        // BDD "expect" style
        expect(add(1, 2)).to.equal(3)

        // TDD "assert" style
        assert.equal(add(1, 2), 3)
    })
})
```

--

* We will use BDD `expect` style:

```
expect(foo).to.be.a('string')
expect(foo).to.equal('bar')
expect(foo).to.have.length(3)
expect(tea).to.have.property('flavors').with.length(3)
```

---

### Testing Javascript: `chai`

* Error output is more useful with `chai`:

```
it('should add three numbers together correctly', () => {
    expect(add(1, 2, 3)).to.equal(6)
})
```

```bash
$ mocha add.spec.js

  add function
    1) should add three numbers together correctly

  0 passing (9ms)
  1 failing

  1) add function should add three numbers together correctly:

      AssertionError: expected 3 to equal 6
      + expected - actual

      -3
      +6

      at Context.<anonymous> (add.spec.js:8:33)
```

---

### Unit testing React apps

* Why unit test React apps?

--

  * Check components render as expected

--

  * ...with different props/state

--

  * Check components can be interacted with as expected

--

  * Check component logic

--

  * Check other application logic e.g. Redux actions



---

### Basic approach

* Simple `Hello World` component

```
// HelloWorld.js
import React from 'react'

export default () => <div>Hello world</div>
```

```
// HelloWorld.spec.js
import { expect } from 'chai'
import React from 'react'
import { createRenderer } from 'react-addons-test-utils'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const renderer = createRenderer()
        renderer.render(<HelloWorld />)

        const actual = renderer.getRenderOutput()

        expect(actual.type).to.equal('div')
        expect(actual.props).to.deep.equal({ children: 'Hello world' })
    })
})
```

???
Quite painful to write/read
Object diffs quite hard to read

---

### Improvement: `jsx-chai`

* https://github.com/bkonkle/jsx-chai, based on [expect-jsx](https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/)

```
import chai, { expect } from 'chai'
import jsxChai from 'jsx-chai'
chai.use(jsxChai)

import React from 'react'
import { createRenderer } from 'react-addons-test-utils'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const renderer = createRenderer()
        renderer.render(<HelloWorld />)

        const actual = renderer.getRenderOutput()

        expect(actual).to.deep.equal(<div>Hello world</div>)
    })
})
```

???
Easier to write/read
Better diffs
Quite brittle

---

# Introducing: `enzyme`

* https://github.com/airbnb/enzyme

* Provides an API for easily asserting, mainpulating and traversing React components output

* Mimick's jQuery's API for DOM manipulation and traversal

* Works with all major test runners and assertion libraries

---

# Introducing: `enzyme`

```
import { expect } from 'chai'
import { shallow } from 'enzyme'
import React from 'react'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<HelloWorld />)

        expect(wrapper.equals(<div>Hello world</div>)).to.be.true
    })
})
```

---

# Introducing: `enzyme`

```
import { expect } from 'chai'
import { shallow } from 'enzyme'
import React from 'react'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<HelloWorld />)

        expect(wrapper.equals(<div>Hello world</div>)).to.be.true

        expect(wrapper.find('<div/>')).to.have.length(1)

        expect(wrapper.contains('Hello world')).to.be.true
    })
})
```

---

# Introducing: `chai-enzyme`

```
import chai, { expect } from 'chai'
import chaiEnzyme from 'chai-enzyme'
chai.use(chaiEnzyme())

import { shallow } from 'enzyme'
import React from 'react'

import HelloWorld from './HelloWorld'

describe('HelloWorld component chai-enzyme', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<HelloWorld />)

        // expect(wrapper.equals(<div>Hello world</div>)).to.be.true
        expect(wrapper).to.have.html('<div>Hello world</div>')

        // expect(wrapper.find('div')).to.have.length(1)
        expect(wrapper).to.have.exactly(1).descendants('div')
        
        // expect(wrapper.contains('Hello world')).to.be.true
        expect(wrapper).to.contain('Hello world')
    })
})
```

---

### Links

* https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'javascript',
        highlightSpans: true,
        highlightStyle: 'sunburst'
      });
    </script>
  </body>
</html>
