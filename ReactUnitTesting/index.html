<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      body {
          font-family: 'Helvetica Neue', Arial, sans-serif;
          font-weight: 200;
      }

      body, a {
          color: white;
      }

      .remark-slide-scaler {
          box-shadow: none;
      }

      .remark-container, .remark-slide-content {
          background: #232323;
      }

      h1, h2, h3 {
        font-family: 'Helvetica Neue', Arial, sans-serif;
        font-weight: 300;
      }

      .remark-code, .remark-inline-code {
          font-family: 'Consolas';
      }

      .remark-code {
          font-size: 16px;
      }

      .remark-slide-number {
          display: none;
      }

      .remark-code-span-highlighted {
          background: none;
          text-decoration: underline;
          color: red;
          font-weight: bold;
      }

      .remark-code-line-highlighted {
          background-color: rgba(255, 0, 0, 0.6);
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Unit Testing<br/>React Applications
<br>
<center><small>Tom Duncalf | <a href='mailto:tom@tomduncalf.com'>tom@tomduncalf.com</a> | <a href='https://twitter.com/tomduncalf'>@tomduncalf</a></small></center>

---

### Overview

* What is unit testing?

* Why unit test?

* `mocha` and `chai`

* Unit testing React components

* `enzyme`

* Common scenarios

---

### What is unit testing?

<blockquote>“Unit testing is a software development process in which the smallest testable parts of an application, called units, are individually and independently scrutinized for proper operation. Unit testing is often automated but it can also be done manually.”</quote>

--

* Example: "`add(1, 1)` should equal `2`"

--

* How small should a unit be?

--

* vs. integration testing, end to end testing

???
How small? ideally testing a small piece of code such as a (public) function with no depedencies on other parts of your code - library dependencies are ok

---

### Why unit test?

--
* Check our code behaves as we expect it to

--

* Check our code handles edge cases/errors correctly

--

* Check our code is syntactically correct (especially in a dynamic language)

--

* Reduce dependency on end-to-end tests - faster, more accurate

--

* Acts as "executable documentation" for our code

--

* Enables refactoring with confidence

--

* Helps writing code where inputs and outputs are known but method isn't

--

* Can help us write better code


???
Dev's opinions on unit testing run from "won't write anything without a unit test" to "won't write a unit test for anything"
Does represent extra effort so why should we do it?

Document e.g. that a certain edge case handling is correct

---

### Testing Javascript: `mocha`

--

* Lots of libraries and tools to choose from: `mocha`, `karma`, `jasmine`, `qunit`, `jsunit`, `wallaby`, `chutzpah`, `ava`, `tape`, `chai`, `sinon`, `jest`...

--

* We will use `mocha` as the core test framework and test runner


```
// add.js
module.exports = (a, b) => a + b
```

```
// add.spec.js
const add = require('./add')

describe('add function', () => {
    it('should add two numbers together correctly', () => {
        if (add(1, 2) !== 3) {
            throw new Error('1 + 2 did not equal 3')
        }

        // or...
        const assert = require('assert')
        assert(add(1, 2) === 3, '1 + 2 did not equal 3')
    })
})

```

```bash
$ npm install -g mocha
$ mocha add.spec.js

  add function
    [✓] should add two numbers together correctly

  [1 passing] (7ms)
```

---

### Testing Javascript: `mocha`

```
describe('add function', () => {
    it('should add two numbers together correctly', () => {
        assert(add(1, 2) === 3, '1 + 2 did not equal 3')
    })

    it('should add three numbers together correctly', () => {
        assert(add(1, 2, 3) === 6, '1 + 2 + 3 did not equal 6')
    })
})
```

```bash
$ mocha add.spec.js

  add function
    ✓ should add two numbers together correctly
    1) should add three numbers together correctly

  1 passing (9ms)
  1 failing

  1) add function should add three numbers together correctly:

       AssertionError: 1 + 2 + 3 did not equal 6
       + expected - actual

       -false
       +true

       at Context.<anonymous> (1a-failures.js:6:9)
```

---

### Testing Javascript: `chai`

--

* `chai` is an assertion library, which allows us to write our assertions in three ways:

```
const add = require('./add')
const chai = require('chai')
chai.should()
const expect = chai.expect
const assert = chai.assert

describe('add function', () => {
    it('should add two numbers together correctly', () => {
        // BDD "should" style
        add(1, 2).should.equal(3)

        // BDD "expect" style
        expect(add(1, 2)).to.equal(3)

        // TDD "assert" style
        assert.equal(add(1, 2), 3)
    })
})
```

--

* We will use BDD `expect` style:

```
expect(foo).to.be.a('string')
expect(foo).to.equal('bar')
expect(foo).to.have.length(3)
expect(tea).to.have.property('flavors').with.length(3)
```

---

### Testing Javascript: `chai`

* Error output is more useful with `chai`:

```
it('should add three numbers together correctly', () => {
    expect(add(1, 2, 3)).to.equal(6)
})
```

```bash
$ mocha add.spec.js

  add function
    1) should add three numbers together correctly

  0 passing (9ms)
  1 failing

  1) add function should add three numbers together correctly:

      AssertionError: expected 3 to equal 6
      + expected - actual

      -3
      +6

      at Context.<anonymous> (add.spec.js:8:33)
```

---

### Unit testing React apps

* Why unit test React apps?

--

  * Check components render as expected

--

  * ...with different props/state

--

  * Check components can be interacted with as expected

--

  * Check component logic

--

  * Check other application logic e.g. Redux actions



---

### Basic approach

* Simple `Hello World` component

```
// HelloWorld.js
import React from 'react'

export default () => <div>Hello world</div>
```

```
// HelloWorld.spec.js
import { expect } from 'chai'
import React from 'react'
import { createRenderer } from 'react-addons-test-utils'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const renderer = createRenderer()
        renderer.render(<HelloWorld />)

        const actual = renderer.getRenderOutput()

        expect(actual.type).to.equal('div')
        expect(actual.props).to.deep.equal({ children: 'Hello world' })
    })
})
```

???
Quite painful to write/read
Object diffs quite hard to read

---

### Improvement: `jsx-chai`

* https://github.com/bkonkle/jsx-chai, based on [expect-jsx](https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/)

```
import chai, { expect } from 'chai'
import jsxChai from 'jsx-chai'
chai.use(jsxChai)

import React from 'react'
import { createRenderer } from 'react-addons-test-utils'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const renderer = createRenderer()
        renderer.render(<HelloWorld />)

        const actual = renderer.getRenderOutput()

        expect(actual).to.deep.equal(<div>Hello world</div>)
    })
})
```

???
Easier to write/read
Better diffs
Quite brittle

---

### Introducing: `enzyme`

* https://github.com/airbnb/enzyme

* Provides an API for easily asserting, mainpulating and traversing React components output

* Mimick's jQuery's API for DOM manipulation and traversal

* Works with all major test runners and assertion libraries

---

### Introducing: `enzyme`

```
import { expect } from 'chai'
import { shallow } from 'enzyme'
import React from 'react'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<HelloWorld />)

        expect(wrapper.equals(<div>Hello world</div>)).to.be.true
    })
})
```

---

### Introducing: `enzyme`

```
import { expect } from 'chai'
import { shallow } from 'enzyme'
import React from 'react'

import HelloWorld from './HelloWorld'

describe('HelloWorld component', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<HelloWorld />)

        expect(wrapper.equals(<div>Hello world</div>)).to.be.true

        expect(wrapper.find('<div/>')).to.have.length(1)

        expect(wrapper.contains('Hello world')).to.be.true
    })
})
```

---

### Introducing: `chai-enzyme`

```
import chai, { expect } from 'chai'
import chaiEnzyme from 'chai-enzyme'
chai.use(chaiEnzyme())

import { shallow } from 'enzyme'
import React from 'react'

import HelloWorld from './HelloWorld'

describe('HelloWorld component chai-enzyme', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<HelloWorld />)

        // expect(wrapper.equals(<div>Hello world</div>)).to.be.true
        expect(wrapper).to.have.html('<div>Hello world</div>')

        // expect(wrapper.find('div')).to.have.length(1)
        expect(wrapper).to.have.exactly(1).descendants('div')

        // expect(wrapper.contains('Hello world')).to.be.true
        expect(wrapper).to.contain('Hello world')
    })
})
```

---

### Real world usage

* Testing a simple to do app

<img src="images/todo-app.png" style="width: 100%" />

---

### Code / Demo

---

### Testing: setup

* npm `test` script to load Babel compiler and path for "absolute" includes

```
"scripts": {
    "test": "NODE_PATH=src mocha --compilers js:babel-register " +
    "--require ./test/helper.js 'src/**/*.spec.js*'"
},
```

* Create a test helper file to load extensions and do any other initialisation

```
import chai from 'chai'
import chaiEnzyme from 'chai-enzyme'
chai.use(chaiEnzyme())
```

---

### Testing: rendering TodoApp

* Test the `TodoApp` component renders the correct components

```html
<div>
    <TodoList items={this.state.items} onItemDone={this.markItemDone.bind(this)} />
    <TodoInput onAddItem={this.addItem.bind(this)} />
</div>
```
--

Rendered output:

```html
<div>
    <ul></ul>
    <form>
        Add item: <input type="text"><button type="submit">Add</button>
    </form>
</div>
```

--

Shallow rendered output:

```html
<div>
    <TodoList items={this.state.items} onItemDone={this.markItemDone.bind(this)} />
    <TodoInput onAddItem={this.addItem.bind(this)} />
</div>
```

---

### Testing: rendering TodoApp

* Test the `TodoApp` component renders the correct components

```html
<div>
    <TodoList items={this.state.items} onItemDone={this.markItemDone.bind(this)} />
    <TodoInput onAddItem={this.addItem.bind(this)} />
</div>
```

--

```
// TodoApp.spec.jsx
import { expect } from 'chai'
import { shallow } from 'enzyme'
import React from 'react'

import TodoApp from './TodoApp'
import TodoList from './TodoList'
import TodoInput from './TodoInput'

describe('TodoApp', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<TodoApp />)

        expect(wrapper).to.have.exactly(1).descendants(TodoList)
        expect(wrapper).to.have.exactly(1).descendants(TodoInput)
    })
})
```

---

### Testing: rendering TodoInput

* Test the `TodoInput` component renders the correct elements

```html
<form onSubmit={this.addItem.bind(this)}>
    Add item: <input type='text' ref='input' />
    <button type='submit'>Add</button>
</form>
```

--

```
// TodoInput.spec.jsx
import TodoInput from './TodoInput'

describe('TodoInput', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<TodoInput />)

        expect(wrapper).to.have.exactly(1).descendants('form')
        expect(wrapper.find('form')).to.have.exactly(1).descendants('input')
        expect(wrapper.find('form')).to.have.exactly(1).descendants('button')
    })
})
```

---

### Testing: rendering TodoInput

* Example error output if the `button` is missing:

```bash
1) TodoInput should render correctly:
    AssertionError: expected the node in <TodoInput /> to have 1
        descendants 'button' but actually found 0

    HTML:

    <form>Add item:
      <input type="text" />
    </form>
```

---

### Testing: rendering TodoItem

* Test the `TodoItem` component renders correctly - depends on `props`

```html
<li>
    <span className={item.done ? 'done' : ''}>{item.item}</span>
    &nbsp;<a href='#' onClick={onDone}>{ item.done ? 'Not done' : 'Done' }</a>
</li>
```

--

```
import TodoItem from './TodoItem'

describe('TodoItem', () => {
    it('should render correctly', () => {
        const wrapper = shallow(<TodoItem item={{ item: 'Test' }} />)

        expect(wrapper).to.have.exactly(1).descendants('li')

        expect(wrapper).to.have.exactly(1).descendants('span')
        expect(wrapper.find('span')).to.have.text('Test')

        expect(wrapper).to.have.exactly(1).descendants('a')
        expect(wrapper.find('a')).to.have.text('Done')
    })
})
```

---

### Testing: rendering TodoItem

* We can use test names to describe intended behaviour - "living documentation"

```html
<li>
    <span className={item.done ? 'done' : ''}>{item.item}</span>
    &nbsp;<a href='#' onClick={onDone}>{ item.done ? 'Not done' : 'Done' }</a>
</li>
```

```
import TodoItem from './TodoItem'

describe('TodoItem', () => {
*   it('should render the item as not done if "done" is not passed in', () => {
        const wrapper = shallow(<TodoItem item={{ item: 'Test' }} />)

        expect(wrapper).to.have.exactly(1).descendants('li')

        expect(wrapper).to.have.exactly(1).descendants('span')
        expect(wrapper.find('span')).to.have.text('Test')

        expect(wrapper).to.have.exactly(1).descendants('a')
        expect(wrapper.find('a')).to.have.text('Done')
    })
})
```

---

### Testing: rendering TodoItem

* Refactor out common code - easier to test various scenarios and update tests

```
function assertItem(wrapper, text, linkText) {
    expect(wrapper).to.have.exactly(1).descendants('li')
    expect(wrapper).to.have.exactly(1).descendants('span')
    expect(wrapper.find('span')).to.have.text(text)
    expect(wrapper).to.have.exactly(1).descendants('a')
    expect(wrapper.find('a')).to.have.text(linkText)
}

describe('TodoItem', () => {
    it('should render the item as not done if "done" is not passed in', () => {
        const wrapper = shallow(<TodoItem item={{ item: 'Test' }} />)
        assertItem(wrapper, 'Test', 'Done')
    })

    it('should render the item as not done if "done" is false', () => {
        const wrapper = shallow(<TodoItem item={{ item: 'Test', done: false }} />)
        assertItem(wrapper, 'Test', 'Done')
    })

    it('should render the item as done if "done" is true', () => {
        const wrapper = shallow(<TodoItem item={{ item: 'Test', done: true }} />)
        assertItem(wrapper, 'Test', 'Not done')
    })
})
```

???
But avoid replicating business logic in tests - keep it quite dumb!

---

### Testing: rendering TodoItem

* We can test CSS classes are output correctly too

```
function assertItem(wrapper, text, done) {
    expect(wrapper).to.have.exactly(1).descendants('li')

    expect(wrapper).to.have.exactly(1).descendants('span')
    expect(wrapper.find('span')).to.have.text(text)
    expect(wrapper.find('span')).to.have.className(done ? 'done' : '')

    expect(wrapper).to.have.exactly(1).descendants('a')
    expect(wrapper.find('a')).to.have.text(done ? 'Not done' : 'Done')
}

describe('TodoItem', () => {
    // ...
    it('should render the item as not done if "done" is false', () => {
        const wrapper = shallow(<TodoItem item={{ item: 'Test', done: false }} />)
        assertItem(wrapper, 'Test', true)
    })

    it('should render the item as done if "done" is true', () => {
        const wrapper = shallow(<TodoItem item={{ item: 'Test', done: true }} />)
        assertItem(wrapper, 'Test', false)
    })
})
```

???
haven't tested interaction yet - will come back to it
---

### Testing: rendering TodoList

* Test the `TodoList` component renders correctly - depends on `props`

```html
<ul>
    { items.map((item, index) =>
        <TodoItem key={index} item={item} onDone={onItemDone.bind(null, index)} />) }
</ul>
```

```
const getWrapper = (items) => shallow(<TodoList items={items} onItemDone={() => {}} />)

describe('TodoList', () => {
    it('should render no items for an empty list', () => {
        const wrapper = getWrapper([])

        expect(wrapper).to.have.exactly(1).descendants('ul')
        expect(wrapper.find('ul')).to.not.have.descendants(TodoItem)
    })

    it('should render items', () => {
        const items = [{ item: 'item 1' }, { item: 'item 2', done: true }]
        const wrapper = getWrapper(items)

        expect(wrapper).to.have.exactly(1).descendants('ul')
        expect(wrapper.find('ul')).to.have.exactly(2).descendants(TodoItem)
        expect(wrapper.find(TodoItem).at(0).prop('item')).to.deep.equal(items[0])
        expect(wrapper.find(TodoItem).at(1).prop('item')).to.deep.equal(items[1])
    })
})
```

---

### Testing: interaction with `TodoItem`

* Introducing `sinon` and `sinon-chai` - we can use a `spy` to verify callback was called

--

```
describe('TodoItem', () => {
    describe('rendering', () => {
        // it('should render the item...
    })

    describe('clicking done', () => {
        it('should call the onDone callback when clicking "Done"', () => {
            const onDone = spy()
            const wrapper = shallow(<TodoItem item={{ item: '1' }} onDone={onDone} />)

            wrapper.find('a').simulate('click')

            expect(onDone).to.have.been.calledOnce
        })
    })
})

```

---

### Testing: interaction with `TodoInput`

* We need to interact with the DOM - not suppoted with `shallow`, so we need to use `mount` ...

--

* ... which requires a DOM. Introducing: `jsdom`, a Javascript implementation of the DOM spec

--

* Add to `test/helper.js` (from [here](https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md)):

```
import { jsdom } from 'jsdom'

var exposedProperties = ['window', 'navigator', 'document']

global.document = jsdom('')
global.window = document.defaultView
Object.keys(document.defaultView).forEach((property) => {
	if (typeof global[property] === 'undefined') {
    	exposedProperties.push(property)
    	global[property] = document.defaultView[property]
    }
})

global.navigator = {
    userAgent: 'node.js'
}
```

---

### Testing: interaction with `TodoInput`

* We can now write a test that interacts with the DOM

```
addItem(e) {
    e.preventDefault()
    this.props.onAddItem(this.refs['input'].value)
    this.refs['input'].value = ''
}

render() {
    return <form onSubmit={this.addItem.bind(this)}>
        Add item: <input type='text' ref='input' /> <button type='submit'>Add</button>
    </form>
}
```

```
describe('submitting', () => {
    it('should call the callback and clear the input on clicking the button', () => {
        const onAddItem = spy()
        const wrapper = mount(<TodoInput onAddItem={onAddItem} />)

        wrapper.find('input').get(0).value = 'test'
        wrapper.find('input').simulate('change')
        wrapper.find('form').simulate('submit')

        expect(onAddItem).to.have.been.calledWith('test')
        expect(wrapper.find('input').get(0).value).to.equal('')
    })
})
```
---

### Testing: `TodoApp`

* We want to test that items are properly added and marked as done

```
addItem(item) {
    this.setState({ items: this.state.items.concat([{ item }]) })
}

markItemDone(index) {
    const newItems = this.state.items.slice(0)
    newItems[index].done = newItems[index].done ? false : true
    this.setState({ items: newItems })
}

render() {
    return <div>
        <TodoList items={this.state.items} onItemDone={this.markItemDone.bind(this)} />
        <TodoInput onAddItem={this.addItem.bind(this)} />
    </div>
}
```

---

### Testing: `TodoApp`

* One approach could be to test that the callbacks change the state:

```
describe('adding items (by calling callbacks and checking state)', () => {
    it('should add an item to an empty list', () => {
        const wrapper = shallow(<TodoApp />)
        wrapper.find(TodoInput).at(0).prop('onAddItem')('test')
        expect(wrapper.state('items')).to.deep.equal([{ item: 'test' }])
    })
})
```

---

### Testing: `TodoApp`

* One approach could be to test that the callbacks change the state:

```
describe('adding items (by calling callbacks and checking state)', () => {
    it('should add an item to an empty list', () => {
        const wrapper = shallow(<TodoApp />)
        wrapper.find(TodoInput).at(0).prop('onAddItem')('test')
        expect(wrapper.state('items')).to.deep.equal([{ item: 'test' }])
    })

    it('should add an item to a list with one item', () => {
        const wrapper = shallow(<TodoApp />)
        wrapper.setState({ items: [{ item: 'test 1' }] })
        wrapper.find(TodoInput).at(0).prop('onAddItem')('test 2')
        expect(wrapper.state('items')).to.deep.equal([{ item: 'test 1' },
            { item: 'test 2' }])
    })
})
```

---

### Testing: `TodoApp`

* One approach could be to test that the callbacks change the state:

```
describe('adding items (by calling callbacks and checking state)', () => {
    it('should add an item to an empty list', () => {
        const wrapper = shallow(<TodoApp />)
        wrapper.find(TodoInput).at(0).prop('onAddItem')('test')
        expect(wrapper.state('items')).to.deep.equal([{ item: 'test' }])
    })

    it('should add an item to a list with one item', () => {
        const wrapper = shallow(<TodoApp />)
        wrapper.setState({ items: [{ item: 'test 1' }] })
        wrapper.find(TodoInput).at(0).prop('onAddItem')('test 2')
        expect(wrapper.state('items')).to.deep.equal([{ item: 'test 1' },
            { item: 'test 2' }])
    })
})

describe('marking items done (by calling callbacks and checking state)', () => {
    it('should mark an item as done', () => {
        const wrapper = shallow(<TodoApp />)
        wrapper.setState({ items: [{ item: 'test 1' }, { item: 'test 2' }] })
        wrapper.find(TodoList).at(0).prop('onItemDone')(0)
        expect(wrapper.state('items')).to.deep.equal([{ item: 'test 1', done: true },
            { item: 'test 2' }])
    })
})
```

---

### Testing: `TodoApp`

* However, this depends on implementation details (like unit testing private methods) - a better approach might be to "integration test" the component using `mount`

--

```
function addItem(wrapper, item) {
    wrapper.find('input').get(0).value = item
    wrapper.find('input').simulate('change')
    wrapper.find('form').simulate('submit')
}

function assertItems(wrapper, items) {
    expect(wrapper).to.have.exactly(items.length).descendants('li')
    items.forEach((item, index) => {
        const itemLi = wrapper.find('li').at(index)
        expect(itemLi).to.contain.text(item.item)
        expect(itemLi).to.contain.text(item.done ? 'Not done' : 'Done')
    })
}

describe('adding items (using mount)', () => {
    it('should add items to a list', () => {
        const wrapper = mount(<TodoApp />)

        addItem(wrapper, 'test 1')
        assertItems(wrapper, [{ item: 'test 1', done: false }])

        addItem(wrapper, 'test 2')
        assertItems(wrapper, [{ item: 'test 1', done: false },
            { item: 'test 2', done: false }])
    })
})
```

---

### Testing: `TodoApp`

* We can test marking items as done in the same way:

```
describe('marking items done (using mount)', () => {
    it('should mark an item as done', () => {
        const wrapper = mount(<TodoApp />)

        addItem(wrapper, 'test 1')
        addItem(wrapper, 'test 2')
        wrapper.find('li').at(0).find('a').simulate('click')

        assertItems(wrapper, [{ item: 'test 1', done: true },
            { item: 'test 2', done: false }])
    })
})
```

--

* Advantage: implementation can change - as long as output is the same, the test will still pass

---

### Testing: `TodoApp` using `Redux`

* Convert the application to use `Redux` instead of `state`:

```
// index.jsx
import * as React from 'react'
*import * as ReactDOM from 'react-dom'
*import { createStore } from 'redux'
*import { Provider } from 'react-redux'

import TodoApp from 'components/TodoApp'
*import todos from 'redux/todos'

*const store = createStore(todos)

ReactDOM.render(
*   <Provider store={store}>
        <TodoApp />
*   </Provider>,
    document.querySelector('#app')
)
```

---

### Testing: `TodoApp` using `Redux`

* Convert the application to use `Redux` instead of `state`:

```
// redux/todos.js
export const ADD_TODO = 'ADD_TODO'
export const TOGGLE_TODO_DONE = 'TOGGLE_TODO_DONE'

const initialState = { todos: [] }

export default function reducer(state = initialState, action) {
    switch (action.type) {
        case ADD_TODO:
            console.log(Object.assign({}, state, { todos: state.todos.concat([action.item]) }))
            return Object.assign({}, state, { todos: state.todos.concat([action.item]) })
        case TOGGLE_TODO_DONE:
            const newTodos = state.todos.slice(0)
            newTodos[action.index].done = newTodos[action.index].done ? false : true
            return Object.assign({}, state, { todos: newTodos })
        default:
            return state
    }
}

export const addTodo = (item) => ({ type: ADD_TODO, item })
export const toggleTodoDone = (index) => ({ type: TOGGLE_TODO_DONE, index })
```

---

### Testing: `TodoApp` using `Redux`

* Convert the application to use `Redux` instead of `state`:

```
import * as React from 'react'
*import { connect } from 'react-redux'

*import { addTodo, toggleTodoDone } from 'redux/todos'
import TodoList from 'components/TodoList'
import TodoInput from 'components/TodoInput'

*const TodoApp = ({ todos, addTodo, toggleTodoDone }) => (
    <div>
        <TodoList items={`todos`} onItemDone={`toggleTodoDone`} />
        <TodoInput onAddItem={`addTodo`} />
    </div>
)

*const mapStateToProps = (state) => ({ todos: state.todos })

*const mapDispatchToProps = (dispatch) => ({
*   addTodo: (item) => dispatch(addTodo({ item })),
*   toggleTodoDone: (index) => dispatch(toggleTodoDone(index))
*})

*export default connect(
*   mapStateToProps,
*   mapDispatchToProps
*)(TodoApp)
```

---

### Testing: `TodoApp` using `Redux`

<img src="images/test-redux.png" style="width: 88%" />

---

### Testing: `TodoApp` using `Redux`

* Presentational component tests still pass, but connected component doesn't

```brainfuck
Invariant Violation: Could not find "store" in either the context or props of
"Connect(TodoApp)". Either wrap the root component in a <Provider>, or explicitly
pass "store" as a prop to "Connect(TodoApp)".
```

--

* `Redux`-connected components need a `store`, but the `store` is created at the top level (`index.jsx`) so isn't present when component is isolated

---

### Testing: `TodoApp` using `Redux`

* First approach: export undecorated component and `shallow` test it separately

```
`export` const TodoApp = ({ todos, addTodo, toggleTodoDone }) => (
    <div>
        <TodoList items={todos} onItemDone={toggleTodoDone.bind(this)} />
        <TodoInput onAddItem={addTodo.bind(this)} />
    </div>
)

// ...

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(TodoApp)
```

---

### Testing: `TodoApp` using `Redux`

* First approach: export undecorated component and `shallow` test it separately

```
`export` const TodoApp = ({ todos, addTodo, toggleTodoDone }) => (
    <div>
        <TodoList items={todos} onItemDone={toggleTodoDone.bind(this)} />
        <TodoInput onAddItem={addTodo.bind(this)} />
    </div>
)
```

```
// TodoApp.spec.jsx
// ...
import { default as DecoratedTodoApp, TodoApp } from './TodoApp'
// ...

describe('TodoApp (un-decorated)', () => {
    describe('rendering', () => {
        it('should render correctly', () => {
            const wrapper = shallow(<TodoApp />)

            expect(wrapper).to.have.exactly(1).descendants(TodoList)
            expect(wrapper).to.have.exactly(1).descendants(TodoInput)
        })
    })
})
```

---

### Testing: `TodoApp` using `Redux`

* Second approach: create a `store` in the test and pass it through `context`

```
// TodoApp.spec.jsx
import { createStore } from 'redux'
import { default as todosReducer } from 'redux/todos'

function getMounted() {
    const context = { store: createStore(todosReducer) }
    return mount(<DecoratedTodoApp />, { context })
}
```

```
describe('TodoApp (decorated)', () => {
    describe('adding items (using mount)', () => {
        it('should add items to a list', () => {
            const wrapper = getMounted()

            addItem(wrapper, 'test 1')
            assertItems(wrapper, [{ item: 'test 1', done: false }])
        })
    })
})
```

```
// TodoApp.jsx
export const TodoApp = ({ todos, addTodo, toggleTodoDone }) => // ...
TodoApp.contextTypes = { store: React.PropTypes.object }
```

---

* Useful for testing actions, but also for "hybrid E2E" tests without having to interact with UI to set up content
* Can do this with `react-router-redux` and root componnet to test user journeys quickly (e.g. signup form) - show wxample
* quicker to run than e2e tests, less brittle, easier to write than ui element tests

---

### Integration testing

* Testing pyramid

---

### Tips

* `npm run test -- --grep "whatever"`

### Links

* https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/

    </textarea>
    <!--script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script-->
    <script src="lib/remark-latest.min.js"></script
    >
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'javascript',
        highlightLines: true,
        highlightSpans: true,
        highlightStyle: 'sunburst'
      });
    </script>
  </body>
</html>
